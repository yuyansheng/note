# OC高级编程
  
### 自动引用计数

##### 内存管理的思考方式

* 自己生成的对象，自己所持有。
由 $alloc/new/copy/mutableCopy$前缀生成的对象均由自己所持有
* 非自己生成的对象，自己也可以持有。
不是用上面四种方法取得的对象非自己所持有，但是可以使用 $retain$ 方法将对象变为自己所持有
* 不再需要自己持有对象时释放对象。
使用上述几种方式取得的自己持有的对象，在不需要时需要使用 $release$ 方法释放，
使用 $autorelease$ 方法删除的对象会放入到自动释放池内，一定时间后会自行释放。
* 非自己持有的对象，自己无法释放。
如果不是自己持有的对象，自己不需要释放，让对象的持有者释放。

上述中的自己可以视为程序员自己

##### `alloc/retain/release/dealloc` 实现


$alloc$ 使用 $struct$ $obj\underline{}layout$中的 $retained$ 来保存引用计数，并将其写入对象内存头部，然后将对象内存块全部置零后返回指针。

$retain$ 与 $release$ 均是通过将 $retained$ 变量加一或减一来实现，当 $retained$ 变量减少为零时自动调用 $dealloc$ 方法销毁对象

$dealloc$ 仅用来销毁由 $alloc$ 创建的内存块

苹果管理引用计数的方法是通过散列表(引用计数表)来实现

通过内存块头部管理引用计数好处

* 少量代码即可完成
* 能够统一管理引用计数用内存块和对象用内存块

使用散列表方式的好处如下

* 对象用内存块的分配无需考虑内存块的头部
* 引用计数表各项记录中存有内存块的地址，可以从各个记录中追溯到各对象的内存块

##### `autorelease` 实现

调用 $autorelease$ 的对象会被放入一个自动释放池内。当对象离开他的作用域时，自动释放池会被释放掉，同时自动释放池内部所有对象也会一一释放。自动释放池之间的结构类似与栈，当某一个对象调用 $autorelease$ 时会被放置到距离他最近的自动释放池内。


#####    




