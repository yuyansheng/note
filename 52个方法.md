# 52个方法

### 第一章 熟悉 OC 语言

##### 1. OC语言的概念
   *  OC语言为C语言添加类面向对象特性，是C语言的超集。OC使用动态绑定的消息结构，只有在运行时才会检查对象类型。在接收一条消息之后究竟执行哪一种代码由运行时的环境而非编译器决定。
   
   * 所有OC语言的对象所占的内存均在堆空间，使用指针指向对象所在堆空间地址。
   
##### 2. 类的声明文件中尽量少引入其他类头文件

* 除非有必要否则在类的声明文件中不要引入其他头文件，如果要提及其他类尽量使用向前声明

例如:
```
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@class B;

@interface A : NSObject

@property B *b;

@end

NS_ASSUME_NONNULL_END
```
如果想要引用类  B 使用向前声明来引用而不是引入头文件，应该在实现文件中引用类 B 的头文件，这样可以降低类之间的耦合。

* 有时无法使用向前声明，比如需要声明某个协议。这种情况下可以将声明移到匿名分类内，或者将协议单独在某个头文件中在引入。

##### 3. 多使用字面量语法

* 使用字面量语法来创建字符串 数值 数组 字典等。
```
NSArray *objects = @[@"1232", @1, @3, ];
NSString *string = @"firstName";
NSNumber *num = @1;
NSDictionary *personData = @{@"firstName":@"Matt",
                                     @"lastName":@"Galloway",
                                     @"age":@28};
```
* 尽量通过取下标来访问数组和字典中的键所对应元素。
```
id object = objects[1];
id firstName = personData[string];
```
* 字面量语法只可以创建不可变对象。

##### 4.多使用类型常量，少用#define预处理指令

* 预处理指令定义常量不包含类型信息，编译器只会进行替换操作，如果常量值被重新定义编译器也不会产生警告，容易导致应用程序中的常量值与预期不一致
* 在实现文件中使用`static const` 来定义“只在实现文件内可见的常量”
例如: 
```
static cosnt NSTimeInterval kAnimationDuration = 0.3
```
这样就定义了一个名为`kAnimationDuration`的`NSTimeInterval`类型的常量
* 在声明文件中可以用`extern`来声明全局常量，在相关的实现文件中定义常量的值。常量名通常以类名做前缀
```
//.h
extern const NSTimeInterval EOCAnimatedViewAnimationDurantion;
//.m
const NSTimeInterval EOCAnimatedViewAnimationDurantion = 0.3;
```
 
##### 5.用枚举表示状态 选项 和 状态码

* 状态机的状态 传递给方法的选项以及状态码等值都应用 **枚举** 来表示，并且值的名要易懂
```
enum state{ 
    firstState = 0,
    secondState,
    thridState,
};
typedef enum state state
```
* 如果把传递给某个方法的选项表示为枚举类型，多个选项可以同时使用，可以将各个选项定义为2的幂，可以通过与和非互相组合。
```
enum state{ 
    firstState = 1,
    secondState = 1<<1,
    thridState = 1<<2,
};
typedef enum state state
```
* 可以使用NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明底层数据类型这样可以确保枚举是用开发者所选的底层数据类型实现的。
```
enum NS_ENUME(NSUInteger,state){ 
    firstState = 1,
    secondState = 1<<1,
    thridState = 1<<2,
};
typedef enum state state
```
* 小技巧 在处理枚举类型的switch语句中不要实现default分支，这样在加入新的枚举之后编译器会提醒开发者：switch并未处理所有分支

### 第二章 对象 消息 运行期

##### 6. 理解“属性”的概念

1. 可以使用 `@property` 来定义对象中封装的属性
2. 可以用属性特质来制定存储数据所需的语意
* 原子性
在默认情况下编译器合成的方法一般为 $atomicity$ 原子性的。但是建议声明属性时将属性定义为非原子性 $nonatomic$。
* 读/写权限<br/>
`readwrite` (读写) ，属性会拥有获取方法 $(getter)$ 与设置方法 $(setter)$。  <br />
`readonly` (只读)，属性只会由获取方法，但是你可以在匿名分类中重新定义为读写属性。<br/>
`@synthesize` 该语法可以用来制定对应属性的实例变量的名字，默认情况如下：<br/>
`@synthesize first = _first`。

* 内存管理语义 <br/>
`assign` "设置方法"只会针对“纯量类型”的简单赋值操作<br/>
`strong` 表示该属性定义了一种拥有关系。这种属性在设置新值时，设置方法会先保留新值，并释放旧值，然后将新值赋值。<br/>
`weak` 表示该属性定义了一种非拥有关系。这种属性设置新值时，设置方法只会进行简单赋值操作与 $assign$ 类似，属性所指对象被销毁时，属性值会自动清空为 `nil`。<br/>
`unsafe_unretained` 语义与 `assign` 相同但是，此特质适用于对象类型该特质表达一种非拥有关系，但是属性所指对象被销毁时时性质不会自动清空。<br/>
`copy` 表达的所属关系与 $strong$ 类似。但是设置方法并不会保留新值，而是将其“拷贝”确保此属性不会被修改。
* 方法名 <br/>
`getter=<name>` 用来指定获取方法方法名。<br/>
`setter=<name>` 用来指定设置方法方法名。

##### 7.在对象内部尽量直接访问实例变量

* 在对象内部读取数据时，直接通过实例变量来读取，写入数据时通过属性来写。
* 在出事话以及 $dealloc$ 方法中，总是应该直接通过实例变量来读写数据。
* 有时会使用懒方法初始化类得到某种数据 此时通过属性来读取数据

##### 8.理解对象等同性

* 想要检测对象的等同性，需要重写 $isEqual$ 与 $hash$ 方法。
* 相同的对象必须要由相同的哈希码，但是哈希码相同对象不一定相同
* 可以通过需求来定制检测等同性
* $hash$ 方法应尽量使用计算速度快而且玛希码碰撞低的算法
例如：

```
- (NSUInteger)hash{
    NSUInteger firstNameHash = [_firstName hash];
    NSUInteger lastNameHash = [_lastName hash];
    NSUInteger  ageHash = _age;
    return firstNameHash ^ lastNameHash ^ ageHash;
}
```

##### 9.用“类族模式”隐藏实现的细节

* 类族模式可以把实现的细节隐藏在一套简单的公共接口后面。
以下是一套雇员类族的模版

```
//各种子类的类别
typedef NS_ENUM(NSUInteger,EOCEmployeeType){
    EOCEmployeeTypeDeveloper,
    EOCEmployeeTypeDesigner,
    EOCEmployeeTypeFinance,
};
//抽象基类
@interface EOCEmployee : NSObject

@property (copy) NSString *name;

@property NSUInteger salary;

//用来创建对应的 Employ类
+ (EOCEmployee *)employeeWithType:(EOCEmployeeType)type;

- (void)doADaysWork;

@end

@implementation EOCEmployee

+ (EOCEmployee *)employeeWithType:(EOCEmployeeType)type{
    switch(type){
        case EOCEmployeeTypeDeveloper:
            return [EOCEmployeeDeveloper new];
            break;
        case EOCEmployeeTypeDesigner:
            return [EOCEmployeeDesigner new];
            break;
        case EOCEmployeeTypeFinance:
            return [EOCEmployeeFinance new];
            break;
    }
}

- (void)doADaysWork{
    ...
}

@end

//每个实体子类从基类继承而来
@interface EOCEmployeeDeveloper : EOCEmployee
@end

@implementation EOCEmployeeDeveloper

- (void)doADaysWork{
    ...
}

@end
...
```
想要判断某对象是否位于某一个类族中应使用以下代码：

```
id maybeAnAray = /*...*/
if([maybeAnArray isKindOfClass:[NSArray class]])}
    //do
```

* 在向类族中新增实体子类时应遵守以下几条规则
1. 子类应继承该类族中的抽象基类
2. 子类应该定义自己的数据存储方式
3. 子类应当覆写超类文档中指明需要覆写的方法

##### 10.在已有类中使用关联对象存放自定义数据

|              关联类型               | 等效的 $@property$ 属性 |
| --------------------------------- | ---------------------- |
| OBJC_ASSOCIATION_ASSIGN           | $assign$               |
| OBJC_ASSOCIATION_RETAIN_NONATOMIC | $nonatomic,retain$     |
| OBJC_ASSOCIATION_COPY_NONATOMIC   | $nonatomic,copy$       |
| OBJC_ASSOCIATION_RETAIN           | $retain$               |
| OBJC_ASSOCIATION_COPY             | $copy$                 |

* 可以通过关联对象把两个对象链接起来，主要由以下三种用法<br/>
以给定的键和策略为某对象设置关联对象值。<br/>
`void objc_setAssociatedObject(id object, void *key, id value, objec_AssociationPolicy policy)`<br/>
以给定的键从某对象中获取相应的关联对象值<br/>
`void objc_getAssociatedObject(id object, void *key)`<br/>
移除指定对象的所有关联对象<br/>
`void objc_gremoveAssociatedObject(id object)`

* 定义关联对象时可指定内存管理语义，用来模仿定时属性时的拥有关系
* 只有在其他做法不可行时再用关联对象，因为这种做法通常会引入难以查找的bug

##### 11.理解 `objc_msgSend` 的作用

$C$ 语言的函数调用方式是“静态绑定”，在编译时就可以决定运行时所调用的函数。

而 $OC$ 语言如果想要向某个对象传递消息，那就会使用动态绑定机制来决定需要调用的方法，在底层所有的方法都是普通的C语言函数，但是对象收到消息之后究竟调用哪一个方法由运行时决定

给某一个对象发送消息可以这样写：

`id returnValue = [someObject messageName:parameter];`
上述代码中 $someObject$ 叫做 “接收者” $messageName$ 叫做 “选择子” ，选择子和参数 $parameter$ 合起来叫做消息。编译器看到此消息后，会将其转换为一条标准的 $C$ 语言调用，所调用的函数就是 $objc \underline{} msgSend$ 其原型如下:

`void objc_msgSend(id self, SEL cmd, ...)`

第一个参数 $self$ 是接收者，第二个参数代表选择子，后续参数代表，消息中的参数。

比如第一个代码被转化为

`id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter)`

$objc \underline{} msgSend$ 函数会根据接收者和选择子来决定调用的方法 ，$objc \underline{} msgSend$ 会将匹配结果缓存在款素映射表内。

发给某对象的消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行对应代码

##### 12.理解消息转发机制

暂未理解

##### 13.用“方法调配技术” 调试 “黑盒方法”

* 在运行期，可以向类中新增或者替换选择子对应的方法实现
* 使用另一份实现来替换原有的方法实现，这种方式叫做“方法调配” 例如

```
@implementation NSString(EOCMyadditions)
- (NSString *)eoc_myLowercaseString{
    NSString *lowercase = [self eoc_myLowercaseString];
    NSLog(@"%@ => %@",self, lowercase);
    return lowercase;
}
@end

Method originalMethod = class_getInstanceMethod([NSString class],
 @selector(lowercaseString));
        
Method swappedMethod = class_getInstanceMethod([NSString class],
 @selector(eoc_myLowercaseString));
        
method_exchangeImplementations(originalMethod, swappedMethod);
        
```
这样就可以在原有实现中新添加功能
* 一般来说只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。

##### 14.理解“类对象”的用意

$OC$ 中的对象实例都是指向某块内存的指针，描述$OC$对象的数据结构定义在运行期程序头文件内，$id$ 类型定义如下

```
typedef sturct objc_object{
    Class isa;
} *id;
```
其中 “$isa$” 指针定义了对象所属的类，Class对象的定义如下

```
typedef objc_class *Class;
struct objc_class{
    Class isa;
    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methoLists;
    struct objc_cache *cache;
    sturct objc_protocol_list *protocols;
}
```
上述结构体用来存放类的“元数据” ， $Class$ 对象本身也是一个 $OC$ 对象，结构体内的 “ $super \underline{}class$ ” 定义了本类的超类。类对象所属的类型，由“ $isa$ ”指针指向另一个类 叫做“元类” 也就是实例所属于的对象。

`isMemberOfClass`可以判断出对象是否为某个对象的实例。

`isKindOfClass` 可以判断出对象是否时某类的派生类的实例。

尽量使用类型查询方法判断对象类型，不要直接比较类对象可能某些对象实现消息转发功能。

### 第三章接口与API设计

##### 15.用前缀避免命名空间冲突。

* 选择与公司、应用程序或者二者都有关系的名字作为类名的前缀。并在代码中使用这一前。
* 如果开发过程中使用了第三方库，则应该为第三方库加上前缀。


##### 16.提供指定初始化方法

* 在类中应提供一个指定初始化方法，并于文档中指明。其他初始化方法均应调用此方法，例如下：

```
@interface EOCRectangle :NSObject

@property (nonatomic, assign, readonly) float width;

@property (nonatomic, assign, readonly) float height;

- (instancetype)initWithWidth:(float)width andHeight:(float)Height;

@end

@implementation EOCRectangle

- (instancetype)initWithWidth:(float)width andHeight:(float)height{
    if(self = [super init]){
        _width = width;
        _height = height;
    }
    return self;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        self = [self initWithWidth:10 andHeight:10];
    }
    return self;
}

@end
```
上述代码中 `initWithWidth`就是一个指定初始化方式，其他初始化方法是应该调用此初始化方式。

* 子类在指定初始化是应首先调用相对应的超类相关的初始化方式，确保所有属性初始化正常。
* 如果指定初始化的方式和超类不同，那么子类应覆写超类的初始化方式或是抛出异常
* 如果一个类中有多种指定初始化方式那么，每一个初始化都应先调用超类对应的初始化方式，然后再执行与本类任务相关的方法。

##### 17.实现`description`方法

* 实现`description` 方法可以在输出时返回一个有意义的字符串，用来描述对应的实例。方便调试。

```
- (NSString *)description
{
    return [NSString stringWithFormat:@"%@ %@ %@", [self class],_firstName,_lastName];
}
```

* 实现 `debugDescription`可以在调试时输出对应实例信息
 
```
- (NSString *)debugDescription
{
    return [NSString stringWithFormat:@"<%@: %p> %@", [self class], self, @{@"width":[_width stringValue],@"height":[_height stringValue]}];
}
```
在调试时在调试框内输入`po <name>` 即可查看具体的类的信息

##### 18.尽量使用不可变对象。

* 尽量创建不可变对象。
* 如果某个对象仅允许在对象内部修改，可以在匿名分类中将其由 `readonly` 属性修改为 `readwrite` 属性。
* 不要使用可变的集合属性公开，应该使用相应的方法，用来修改对象中的可变集合
* 
```
@interface  EOCPerson: NSObject

@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, strong, readonly) NSSet *friends;

- (void)addFriends:(EOCPerson *)object;
- (void)removeFriends:(EOCPerson *)object;
@end

@interface EOCPerson ()
@property (nonatomic, copy, readwrite) NSString *firstName;
@property (nonatomic, copy, readwrite) NSString *lastName;
@end

@implementation EOCPerson{
    NSMutableSet *_internalFriends;
}

- (NSSet *)friends{
    return [_internalFriends copy];
}

- (void)addFriends:(EOCPerson *)object{
    [_internalFriends addObject:object];
}

- (void)removeFriends:(EOCPerson *)object{
    [_internalFriends removeObject:object];
}
@end
```

##### 使用清晰而协调的命名方式

* 起名时遵从标准的 $OC$ 命名规范。。
* 方法名要言简意骇，读起来要想一个句子。
* 方法名里面不要使用缩略后的类型名称。
* 方法名要确保其风格和自己的代码所继承的框架相符。

##### 为私有方法添加前缀

* 给私有方法的名称加上前缀，这样可以和共有方法作区
* 不要使用一个下划线做私有方法的前缀，这种方式需要预留给苹果公司使用

##### 理解 $OC$ 的错误模型

在自动引用计数下，默认情况不是“异常安全的”。如果抛出异常，那么本应在作用域末尾释放的对象现在就不会释放了，会引发内存泄漏。所以目前 $OC$ 语言采用的异常处理方式是：只在极其罕见的情况下抛出异常，异常抛出后，无需考虑恢复问题，此时应用程序也应该退出。对于不是很言严重的问题 $OC$ 采用的是令方法返回`nill/0` ，或者是使用 `NSError` 。

`NSError`内封装类三条信息

1. $Error$ $domain$(错误范围，通常为字符串)<br/>错误发生的范围。也就是错误发生的根源，通常用一个特有的全局变量类定义。
2. $Error$ $code$(错误代码，通常为整型) <br/>特有的错误代码，用来指明在某个范围内发生类什么错误。某个范围内可能发生类很多相关错误，这些错误通常用枚举定义。
3. $User$ $info$(用户信息，通常为字典)<br/>和这个错误有关的额外信息，其中包含一段“错误描述”，可能还含有导致该错误发生的其他错误，这样可以形成一条“错误链”

```
NSError  *error = nil;
BOOL ret = [object doSomething:&error];
if(error){
    //处理错误
}

- (BOOL)doSomething(NSError**)error{
    
    if(/*发生错误*/){
        if(error){//需要处理错误
            *error = /*错误*/
            
        }
        return NO;
    }else {
        return YES;
    }
}
```

##### 22.理解NSCopying协议                      

如果想要某个类支持拷贝功能需要声明该类遵循 `NSCopying` 协议并实现 `copyWithZone` 方法

比如之前的 `EOCPerson`如果遵循该协议那么就要在加入一个方法


```
- (nonnull id)copyWithZone:(nullable NSZone *)zone { 
    EOCPerson *copy = [[[self class] allocWithZone:zone] init];
    copy->_internalFriends = [_internalFriends mutableCopy];
    return copy;
}
```

这样就可以实现一个深拷贝功能。但是这样返回的是一个不可变对象，如果想要返回一个可变对象，那么需要实现 `NSMutableCopying` 协议。

```
- [NSMutableArray copy] => NSArray;
- [NSArray mutableCopy] => NSMutableArray;
```

一般情况下多进行浅拷贝。

##### 23.通过委托与数据源协议进行对象间通信。
