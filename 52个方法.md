# 52个方法

### 第一章 熟悉 OC 语言

##### 1. OC语言的概念
   *  OC语言为C语言添加类面向对象特性，是C语言的超集。OC使用动态绑定的消息结构，只有在运行时才会检查对象类型。在接收一条消息之后究竟执行哪一种代码由运行时的环境而非编译器决定。
   
   * 所有OC语言的对象所占的内存均在堆空间，使用指针指向对象所在堆空间地址。
   
##### 2. 类的声明文件中尽量少引入其他类头文件

* 除非有必要否则在类的声明文件中不要引入其他头文件，如果要提及其他类尽量使用向前声明

例如:
```
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@class B;

@interface A : NSObject

@property B *b;

@end

NS_ASSUME_NONNULL_END
```
如果想要引用类  B 使用向前声明来引用而不是引入头文件，应该在实现文件中引用类 B 的头文件，这样可以降低类之间的耦合。

* 有时无法使用向前声明，比如需要声明某个协议。这种情况下可以将声明移到匿名分类内，或者将协议单独在某个头文件中在引入。

##### 3. 多使用字面量语法

* 使用字面量语法来创建字符串 数值 数组 字典等。
```
NSArray *objects = @[@"1232", @1, @3, ];
NSString *string = @"firstName";
NSNumber *num = @1;
NSDictionary *personData = @{@"firstName":@"Matt",
                                     @"lastName":@"Galloway",
                                     @"age":@28};
```
* 尽量通过取下标来访问数组和字典中的键所对应元素。
```
id object = objects[1];
id firstName = personData[string];
```
* 字面量语法只可以创建不可变对象。

##### 4.多使用类型常量，少用#define预处理指令

* 预处理指令定义常量不包含类型信息，编译器只会进行替换操作，如果常量值被重新定义编译器也不会产生警告，容易导致应用程序中的常量值与预期不一致
* 在实现文件中使用`static const` 来定义“只在实现文件内可见的常量”
例如: 
```
static cosnt NSTimeInterval kAnimationDuration = 0.3
```
这样就定义了一个名为`kAnimationDuration`的`NSTimeInterval`类型的常量
* 在声明文件中可以用`extern`来声明全局常量，在相关的实现文件中定义常量的值。常量名通常以类名做前缀
```
//.h
extern const NSTimeInterval EOCAnimatedViewAnimationDurantion;
//.m
const NSTimeInterval EOCAnimatedViewAnimationDurantion = 0.3;
```
 
##### 5.用枚举表示状态 选项 和 状态码

* 状态机的状态 传递给方法的选项以及状态码等值都应用 **枚举** 来表示，并且值的名要易懂
```
enum state{ 
    firstState = 0,
    secondState,
    thridState,
};
typedef enum state state
```
* 如果把传递给某个方法的选项表示为枚举类型，多个选项可以同时使用，可以将各个选项定义为2的幂，可以通过与和非互相组合。
```
enum state{ 
    firstState = 1,
    secondState = 1<<1,
    thridState = 1<<2,
};
typedef enum state state
```
* 可以使用NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明底层数据类型这样可以确保枚举是用开发者所选的底层数据类型实现的。
```
enum NS_ENUME(NSUInteger,state){ 
    firstState = 1,
    secondState = 1<<1,
    thridState = 1<<2,
};
typedef enum state state
```
* 小技巧 在处理枚举类型的switch语句中不要实现default分支，这样在加入新的枚举之后编译器会提醒开发者：switch并未处理所有分支

### 第二章 对象 消息 运行期

##### 6. 理解“属性”的概念

1. 可以使用 $@property$ 来定义对象中封装的属性
2. 可以用属性特质来制定存储数据所需的语意
* 原子性
在默认情况下编译器合成的方法一般为 $atomicity$ 原子性的。但是建议声明属性时将属性定义为非原子性 $nonatomic$。
* 读/写权限
$readwrite$ (读写) ，属性会拥有获取方法 $(getter)$ 与设置方法 $(setter)$
$readonly$ (只读)，属性只会由获取方法，但是你可以在匿名分类中重新定义为读写属性
$@synthesize$ 该语法可以用来制定对应属性的实例变量的名字，默认情况如下
`@synthesize first = _first`
* 内存管理语义
$assign$ "设置方法"只会针对“纯量类型”的简单赋值操作
$strong$ 表示该属性定义了一种拥有关系。这种属性在设置新值时，设置方法会先保留新值，并释放旧值，然后将新值赋值。
$weak$ 表示该属性定义了一种非拥有关系。这种属性设置新值时，设置方法只会进行简单赋值操作与 $assign$ 类似，属性所指对象被销毁时，属性值会自动清空为 `nil`。
$unsafe_unretained$ 语义与 $assign$ 相同但是，此特质适用于对象类型该特质表达一种非拥有关系，但是属性所指对象被销毁时时性质不会自动清空。
$copy$ 表达的所属关系与 $strong$ 类似。但是设置方法并不会保留新值，而是将其“拷贝”确保此属性不会被修改。
* 方法名
$getter=<name>$ 用来指定获取方法方法名。
$setter=<name>$ 用来指定设置方法方法名。

##### 7.在对象内部尽量直接访问实例变量

* 在对象内部读取数据时，直接通过实例变量来读取，写入数据时通过属性来写。
* 在出事话以及 $dealloc$ 方法中，总是应该直接通过实例变量来读写数据。
* 有时会使用懒方法初始化类得到某种数据 此时通过属性来读取数据

##### 8.理解对象等同性

* 想要检测对象的等同性，需要重写 $isEqual$ 与 $hash$ 方法。
* 相同的对象必须要由相同的哈希码，但是哈希码相同对象不一定相同
* 可以通过需求来定制检测等同性
* $hash$ 方法应尽量使用计算速度快而且玛希码碰撞低的算法
例如：
```
- (NSUInteger)hash{
    NSUInteger firstNameHash = [_firstName hash];
    NSUInteger lastNameHash = [_lastName hash];
    NSUInteger  ageHash = _age;
    return firstNameHash ^ lastNameHash ^ ageHash;
}
```

##### 9.用“类族模式”隐藏实现的细节
